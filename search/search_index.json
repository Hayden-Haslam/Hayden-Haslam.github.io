{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Hayden-Haslam.github.io","text":""},{"location":"#latest-project","title":"Latest Project","text":"<p>In this project, I am experimenting with the use of a csv file to hold configuration information, stored in a network location, accessible to a machine running a script to use this information to do various things.</p> <p>PowerShell + CSV - Lets go!</p> <p>Previous Projects: See Posts for older content</p>"},{"location":"about/","title":"About Me","text":"<p>My name is Hayden Haslam.</p> <p>I am a Retail System Engineer for Maverik Inc.</p> <p>I have primarily been tasked with building and managing various aspects of my companies retail Windows images.</p> <p>This personal website will be used to help me manage and organize most of the things I have learned along the way.</p> <p>I started this job with very little PowerShell experience, but immediately latched onto the power of PowerShell to help me accomplish most of my automation and building.</p> <p>Hopefully this could benefit someone down the road someday, although it will most likely be myself when I forget how I did something in the past.</p> <p>Please feel free to reach out to me about anything you see here. Feedback, Criticism, Encouragement, etc. All is Welcome </p> <p>Email me at: haslam.hayden@gmail.com</p>"},{"location":"newcustomimage/","title":"May 3, 2024","text":""},{"location":"newcustomimage/#current-project-making-a-script-to-automate-wim-extraction-and-setup","title":"Current Project: Making a script to automate wim extraction and setup","text":"<p>Problem to solve: I need to recreate Windows images every quarter for security and PCI compliance reasons. My current solution to this was to mount my existing <code>install.wim</code> and boot it into audit mode, make whatever changes are needed, and reapply any sysprep stuff, and recapture. This became very tedious very fast with most of the steps being done manually.</p> <p>Goal: I want to create a nice script to do most of the steps for me. I will out line it first with my rough order and where I think the commands need to go for this process. Then I will slowly go through and actually uncomment the commands and make the thing real!</p> <p>Update #1: As I've been working through this, I've made a lot of progress on the logic of the script. I have also been trying to incorporate use of <code>Write-Verbose</code> to leverage some verbose output for troubleshoot purposes, but I am still a little confused on how it exactly works. So for now, disregard the excessive amount for <code>Write-Verbose</code> lines.</p> <p>Update #2: Ive made a lot of changes here. In the future, I will try to do a better job of showing my old way and new way side by side instead of replacing everything at once. But I started practicing the use of Advanced Functions and creating my own cmdlets. I have converted this script into the <code>New-CustomImage</code> cmdlet. I have made two parameters for the two locations that will be needed on the computer. My goal is to have a network location that is accessible to everyone running my script. I set that location as default parameter value, but they can change it if they wish. Same goes for the local location on their computer where the actual image building/manipulation will happen.</p> <p>Since the <code>Mount-WindowsImage</code> cmdlet requires Administrator privileges, I have added <code>#requires -RunAsAdministrator</code> to my function as well. I still have much more to do with this script but I feel like I am making very good progress.</p> <pre><code>#requires -RunAsAdministrator\n\nfunction New-CustomImage {\n    [CmdletBinding()]\n    param(\n        [Parameter(HelpMessage = \"Enter the location on you local computer where you want to make the working directory.\")]\n        [string] $LocalDirectory = 'C:\\zzz',\n        [Parameter(HelpMessage = \"Enter the location that you want to pull the working files from.\")]\n        [string] $NetworkLocation = 'C:\\VM\\workingdirctoryshare'\n        #[Parameter(Mandatory)]\n        #[pscredential] $Credentials\n    )\n\n    # Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ]\"\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Starting Script.\"\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Setting Working Directory to $LocalDirectory.\"\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Testing if $LocalDirectory exists.\"\n    if (!(Test-Path -Path $LocalDirectory -PathType Any)) {\n        Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] $LocalDirectory does not exist, creating now.\"\n        #New-Item -Path 'C:\\' -Name 'workingdirectory' -ItemType Directory\n        New-Item -ItemType Directory -Path $LocalDirectory\n        Write-Warning -Message \"The workingdirectory folder was not present. It has now been created.\"\n    }\n\n    Copy-Item -Path $NetworkLocation\\* -Destination $LocalDirectory -Recurse\n\n    $ISOLocation = (Get-Item -Path $LocalDirectory'\\iso\\*.iso').FullName\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Setting ISO location: $ISOLocation.\"\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Testing if ISO exists.\"\n    if (!(Test-Path -Path $ISOLocation -PathType Leaf)) {\n        Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] ISO does not exist, display Warning and exit.\"\n        Write-Warning -Message \"Iso file is missing. Copy SW_DVD9_WIN_ENT_LTSC_2021_64BIT_English_MLF_X22-84414.ISO into C:\\workingdirectory\\iso and restart script.\"\n        Return\n    }\n\n    $DriverFolder = $LocalDirectory+'\\Drivers'\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Setting Driver folder location: $DriverFolder.\"\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Testing if Driver folder exists.\"\n    if (!(Test-Path -Path $DriverFolder -PathType Any)) {\n        Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] $DriverFolder does not exits, creating now.\"\n        New-Item -Path $LocalDirectory'\\' -Name 'Drivers' -ItemType Directory\n        Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Display Warning and exit.\"\n        Write-Warning -Message \"It looks like the driver folder is empty, add drivers and restart script\"\n        Return\n    }\n\n    # Mount iso file\n    $LocationInfo = (Mount-DiskImage -ImagePath $ISOLocation -PassThru | Get-Volume)\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Mounting ISO for wim extraction.\"\n    $DriveLetter = ($LocationInfo).DriveLetter+':\\'\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] ISO mounted at Driver Letter: $DriveLetter\"\n    $DevicePath = ($LocationInfo | Get-DiskImage).DevicePath\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] ISO mounted at Device Location: $DevicePath\"\n    $WimName = 'Win10Enterprise.wim'\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Setting extracted wim name: $WimName\"\n\n    # Extract LTSC Edition from install.wim in sources directory to working directory\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Extracting Windows 10 LTSC version from install.wim to $LocalDirectory\"\n    Dism /Export-Image /SourceImageFile:$DriveLetter\\sources\\install.wim /SourceIndex:1 /DestinationImageFile:$LocalDirectory\\iso\\$WimName\n\n    # Unmount iso file\n    Write-Verbose -Message \"[ $((Get-Date).TimeOfDay.ToString()) ] Dismount ISO file from $DevicePath\"\n    Dismount-DiskImage -DevicePath $DevicePath\n\n    # Rename the wim index to our own thing\n        # Using dism run below\n        # Imagex /info \"&lt;PATH TO IMAGE&gt;\" &lt;Index Number&gt; \"&lt;NEW IMAGE NAME&gt;\" \"&lt;NEW IMAGE DESCRIPTION&gt;\"\n        # Impossible unless ran from the Deployment tools utility\n\n    # Mount wim file\n    New-Item -Path $LocalDirectory -Name 'MountFolder' -ItemType Directory\n    $MountFolder = $LocalDirectory+'\\MountFolder'\n    $WimLocation = $LocalDirectory+'\\iso\\'+$WimName\n    Mount-WindowsImage -ImagePath $WimLocation -Index 1 -Path $MountFolder\n\n    # Inject device drivers\n    dism /Image:$MountFolder /Add-Driver /Driver:$DriverFolder /Recurse\n\n    &lt;# Windows Updates from WSUS\n        # Set Server\n        $WSUSServer = 'PC01.lab.test' # eventually on Legend\n        # Set OS type\n        $OSName = 'Windows 10 LTSB' # Might need to fix\n\n        # Install Update tools\n        Install-WindowsFeature UpdateServices-API\n\n        # Set folder for downloading updates\n        $UpdateFolder = New-Item -Path $LocalDirectory -Name 'Updates' -ItemType Directory\n\n        # Connect to WSUS server\n        $WSUSConnection = Get-WsusServer -Name $WSUSServer -PortNumber 8530\n        $AllUpdates = $WSUSConnection.GetUpdates()\n\n        $OSUpdates = $AllUpdates | Where-Object {$OSName -in $_.ProductTitles -and $_.IsApproved -eq $true -and $_.IsSuperseded -eq $false}\n\n        foreach($Update in $OSUpdates) {\n            $CabURIs = $Update.GetInstallableItems() | Select-Object -ExpandProperty Files | Where-Object {$_.Type -eq 'SelfContained'} | Select-Object -ExpandProperty FileUri | Select-Object -ExpandProperty AbsoluteUri\n            foreach($CabURI in $CabURIs) {\n                # $CabFile = $CabURI | Split-Path -Leaf\n                $CabPath = $CabURI.Replace('/','\\').Replace('http:','').Replace(':','').Replace(':8530','\\C$').Replace('Content','WSUS\\WsusContent')\n                Copy-Item -Path $CabPath -Destination $UpdateFolder\n            }\n        }\n\n        $UpdateFiles = Get-ChildItem $UpdateFolder | Select-Object -ExpandProperty FullName\n\n        foreach ($AvailableUpdate in $UpdateFiles) {\n            Add-WindowsPackage -PackagePath $AvailableUpdate -Path $MountFolder\n        }\n    #&gt;\n\n    # Make Audit Mode answer file\n        # To configure Windows to boot to audit mode, add the Microsoft-Windows-Deployment | Reseal | Mode = audit\n        Copy-Item -Path $LocalDirectory'\\iso\\unattend.xml' -Destination $MountFolder'\\Windows\\System32\\Sysprep'\n        Copy-Item -Path $LocalDirectory'\\iso\\CustomOOBE' -Destination $MountFolder'\\Windows\\System32\\Sysprep' -Recurse\n        # Run script on first time start up\n            # Install-Module -Name PSWindowsUpdate\n            # Get-WindowsUpdate -AcceptAll\n\n    # Copy sysprep files into sysprep folder in image\n        # Copy-Item\n\n    # Unmount wim file\n    Dismount-WindowsImage -path $MountFolder -save\n\n    # Rename wim file\n        # Rename-File -Path &lt;path to install.wim&gt; -NewName &lt;New Name of wim&gt;\n\n    # Hyper-V automated setup\n        # Build Virtual Machine\n        # ? Mount VHD \n        # $vhdfile = $LocalDirectory+'\\iso\\temp.vhdx'\n        # New-VHD -Path $vhdfile -Dynamic -SizeBytes 30GB | Mount-VHD -Passthru | Initialize-Disk -Passthru -Confirm:$false\n        # $disknumber = (Get-DiskImage -ImagePath $vhdfile | Get-Disk).Number\n        # ? Run Diskpart commands to format the drive correctly\n        # ? Expand-WindowsImage and &lt;cmd.exe /c \"bcdboot W:\\Windows /s S: /f ALL\"&gt; to apply wim to vhd drive\n        # ? Unmount vhd drive\n        # ? Assign vhd to Virtual Machine\n        # ? Start Virtual Machine\n\n    # Boot Virtual Machine\n        # Audit Mode boots automatically and runs Startup script\n\n    # In startup Script\n        # Check for windows updates - Install Windows update module from PSGallery\n        # Reconfigure sysprep folder for actual install - New answer file, etc.\n        # ? Other Stuff?\n        # ? Disk clean up, remove old windows installs, etc.\n        # ? Figure out a way to get through multiple reboot automatically for updates\n        # Shutdown Image with generalize and sysprep ready to go\n\n    # Capture VHD to wim\n        # might need to do some fancy winpe stuff\n\n    # Test booting the image to verify successful configuration\n        # Verify sysprep processes correctly\n        # Verify start up scripts process correctly\n\n    # Clean up\n        # ? Maybe remove all Hyper-V stuff\n        # If using WDS, copy new image to WDS\n}\n</code></pre>"},{"location":"posts/","title":"All Posts","text":"<p>July 05, 2024 PowerShell + CSV - Lets go!</p> <p>May 03, 2024 Building a Custom Image</p>"},{"location":"pscsv/","title":"PowerShell + CSV","text":""},{"location":"pscsv/#the-why","title":"The Why","text":"<p>I was recently assigned a new role/project where I will be administering a set of servers that run a complex program for my company. One of my first tasks as part of my training was to take some data from a csv file, containing 4 pieces of data per object, and generate an xml configuration file to be imported. The rest of the details aren't really important here, but my take away from this was how awesome it was to use a csv file as a source of data for a PowerShell script. Day 1 into training with this Administrator I will be replacing, and I have already learned something new. I have already thought of a way I can apply this to my current role. That is what I will be covering in this post.</p>"},{"location":"pscsv/#goal","title":"Goal","text":"<p>As mentioned above, I will be creating a PowerShell script that will run on a newly created machine in my environment that will reach out to an available network share, import the csv containing various configuration data, and do something with it to set up the device.</p> <p>In the past, I found myself hard-coding things in my scripts like application installer names, local and network file destination paths, etc. I thought I could build a master cvs file, containing all the information relevant to the setup process and put in a place that is unlikely to change. Then, I only need to worry about managing the master spreadsheet, and make less changes to multiple scripts.</p> <p>The part I am going to focus on for now is the program installation phase. This part of the csv will contain the name of the application that will be installed, the network location to pull it from, and the local destination on the computer to copy the file to.</p>"},{"location":"pscsv/#example-csv","title":"Example CSV","text":"<p>In my environment, I have computers that serve multiple functions and need to be set up accordingly, even though they use the same windows image and start up scripts. I will label these as type_1 and type_2 here.</p> device_type application_name network_location local_directory type_1 Application 1 App1* C:\\temp\\software\\App1 type_1 Application 2 App2* C:\\temp\\software\\App2 type_2 Application 3 App3* C:\\temp\\software\\App3 type_2 Application 4 App4* C:\\temp\\software\\App4"},{"location":"pscsv/#the-script","title":"The Script","text":"<p>I am going to start by setting a variable for my network share. This will be the only network directory that will be hard-coded into my script because it is unlikely to change.</p> <pre><code>$networkshare = '\\\\networkshare\\software\\'\n</code></pre> <p>Next, I will create a <code>New-PSDrive</code> as my connection point to the network share so I only need to authenticate once. Note: the credentials are being gathered from another part of the script.</p> <pre><code>New-PSDrive -Name 'Share' -PSProvider Filesystem -Root $networkshare -Credential $Credentials\n</code></pre> <p>Import the csv file.</p> <pre><code>$csvpath = 'C:\\temp\\csvpath\\test.csv'\n$csv = Import-Csv -Path $csvpath\n</code></pre> <p>Time for the file transfers. I am using <code>Start-BitsTransfer</code> here for the progress bar since I plan on incorporating this into a larger script which includes a GUI.</p> <pre><code>$csv | Where-Object device_type -eq 'type_1' | ForEach-Object {\n    $source = \"Share:\\\"+($_).network_location\n    if (!(Test-Path $_.local_directory)) {New-Item -Path $_.local_directory -ItemType Directory}\n    Start-BitsTransfer -Source $source -Destination $_.local_directory\n}\n</code></pre> <p>Remove PSDrive when done.</p> <pre><code>Remove-PSDrive -Name 'Share'\n</code></pre>"}]}